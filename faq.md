Here are **5 very common interview questions** based **exactly on the code you saw**, focused on **how a micro frontend exposes a component and how the container consumes it**â€”with **clear, short, interview-ready answers**.

---

## 1ï¸âƒ£ How does a micro frontend expose its component to the container app?

**Answer:**
A micro frontend exposes its component using **Webpack Module Federation** via the `exposes` property.

**Code reference (Product Micro Frontend):**

```js
new ModuleFederationPlugin({
  name: "productApp",
  filename: "remoteEntry.js",
  exposes: {
    "./ProductApp": "./src/ProductApp"
  }
});
```

**Explanation (say this):**

> â€œThe micro frontend exposes components by mapping a public name to a local file using the `exposes` configuration. This generates a `remoteEntry.js` file that the container can load at runtime.â€

---

## 2ï¸âƒ£ What is `remoteEntry.js` and why is it important?

**Answer:**
`remoteEntry.js` is the **entry file generated by Module Federation** that contains metadata about exposed modules.

**Explanation:**

* Acts as a **manifest**
* Tells the container:

  * What modules are exposed
  * How to load them
* Loaded dynamically at runtime

**Interview line:**

> â€œThe container loads `remoteEntry.js` to discover and import exposed micro frontend components without rebuilding.â€

---

## 3ï¸âƒ£ How does the container app know where the micro frontend is deployed?

**Answer:**
The container app defines the micro frontend location using the **`remotes` configuration** in Module Federation.

**Code reference (Container App):**

```js
remotes: {
  productApp: "productApp@http://localhost:3001/remoteEntry.js"
}
```

**Explanation:**

> â€œThe `remotes` config maps a logical name to the URL of the micro frontendâ€™s `remoteEntry.js`, allowing runtime loading.â€

---

## 4ï¸âƒ£ How does the container app import and render a micro frontend component?

**Answer:**
The container app imports the exposed component using **dynamic import + React.lazy**.

**Code reference:**

```js
const ProductApp = React.lazy(() => import("productApp/ProductApp"));
```

Then renders it:

```js
<Route path="/products" element={<ProductApp />} />
```

**Interview explanation:**

> â€œThe container uses dynamic imports to load remote components lazily at runtime and renders them like normal React components.â€

---

## 5ï¸âƒ£ How is React shared between container and micro frontends, and why?

**Answer:**
React is shared as a **singleton dependency** to avoid loading multiple React instances.

**Code reference (both apps):**

```js
shared: {
  react: { singleton: true },
  "react-dom": { singleton: true }
}
```

**Explanation:**

* Prevents version conflicts
* Avoids hooks errors
* Improves performance

**Interview one-liner:**

> â€œReact is shared as a singleton to ensure all micro frontends use the same React instance.â€

---

## â­ Bonus 30-Second Summary (Very Powerful)

> â€œA micro frontend exposes components using Module Federationâ€™s `exposes` config, which generates a `remoteEntry.js`. The container app registers this file using `remotes` and dynamically imports exposed components at runtime using `React.lazy`. Shared dependencies like React are marked as singletons to avoid duplication.â€

---

If you want next:

* ğŸ”¹ **5 advanced follow-up questions**
* ğŸ”¹ **Error handling when MF fails**
* ğŸ”¹ **Version mismatch scenarios**
* ğŸ”¹ **How MF talks to backend**

Just say ğŸ‘
